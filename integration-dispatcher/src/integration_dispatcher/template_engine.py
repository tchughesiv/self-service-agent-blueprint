"""Template engine for integration message formatting."""

from typing import Any, Dict

import jinja2
from shared_models import get_enum_value
from shared_models.models import IntegrationTemplate, IntegrationType
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession


class TemplateEngine:
    """Template engine for rendering integration messages."""

    def __init__(self) -> None:
        self.jinja_env = jinja2.Environment(
            loader=jinja2.DictLoader({}),
            autoescape=jinja2.select_autoescape(["html", "xml"]),
        )

        # Add custom filters
        self.jinja_env.filters["truncate_words"] = self._truncate_words
        self.jinja_env.filters["markdown_to_slack"] = self._markdown_to_slack
        self.jinja_env.filters["markdown_to_html"] = self._markdown_to_html

    async def render(
        self,
        integration_type: IntegrationType,
        subject: str,
        content: str,
        variables: Dict[str, Any],
        db: AsyncSession,
        template_name: str | None = None,
    ) -> Dict[str, str]:
        """
        Render templates for an integration type.

        Args:
            integration_type: Type of integration
            subject: Original subject/title
            content: Original content
            variables: Template variables
            db: Database session
            template_name: Specific template name (optional)

        Returns:
            Dict with rendered 'subject' and 'body' content
        """
        # Get template from database
        template = await self._get_template(integration_type, template_name or "", db)

        # Prepare template variables
        template_vars = {
            "subject": subject,
            "content": content,
            "integration_type": get_enum_value(integration_type),
            **variables,
        }

        # Render subject and body
        rendered_subject = subject
        rendered_body = content
        template_used = None

        if template:
            template_used = (
                str(template.template_name) if template.template_name else None
            )

            # Render subject if template has one
            if template.subject_template:
                subject_template = self.jinja_env.from_string(
                    str(template.subject_template)
                )
                rendered_subject = subject_template.render(**template_vars)

            # Render body
            if template.body_template:
                body_template = self.jinja_env.from_string(str(template.body_template))
                rendered_body = body_template.render(**template_vars)
        else:
            # Use default formatting based on integration type
            rendered_subject, rendered_body = self._apply_default_formatting(
                integration_type, subject, content, template_vars
            )

        return {
            "subject": rendered_subject,
            "body": rendered_body,
            "template_name": template_used or "",
        }

    async def _get_template(
        self,
        integration_type: IntegrationType,
        template_name: str,
        db: AsyncSession,
    ) -> IntegrationTemplate:
        """Get template from database."""
        if template_name:
            # Get specific template
            stmt = select(IntegrationTemplate).where(
                IntegrationTemplate.integration_type == integration_type,
                IntegrationTemplate.template_name == template_name,
                IntegrationTemplate.is_active == True,  # noqa: E712
            )
        else:
            # Get default template
            stmt = select(IntegrationTemplate).where(
                IntegrationTemplate.integration_type == integration_type,
                IntegrationTemplate.is_default == True,  # noqa: E712
                IntegrationTemplate.is_active == True,  # noqa: E712
            )

        result = await db.execute(stmt)
        return result.scalar_one_or_none()

    def _apply_default_formatting(
        self,
        integration_type: IntegrationType,
        subject: str,
        content: str,
        variables: Dict[str, Any],
    ) -> tuple[str, str]:
        """Apply default formatting when no template is found."""
        if integration_type == IntegrationType.SLACK:
            # Format for Slack
            formatted_subject = f"ðŸ¤– {subject or 'Agent Response'}"
            formatted_body = f"*{subject or 'Response'}*\n\n{content}"

            if variables.get("agent_id"):
                formatted_body += f"\n\n_From: {variables['agent_id']}_"

        elif integration_type == IntegrationType.EMAIL:
            # Format for Email
            formatted_subject = f"[Self-Service Agent] {subject or 'Response'}"
            formatted_body = content

            if variables.get("agent_id"):
                formatted_body += (
                    f"\n\n---\nResponse generated by: {variables['agent_id']}"
                )

        elif integration_type == IntegrationType.SMS:
            # Format for SMS (keep it short)
            formatted_subject = "Agent Response"
            formatted_body = self._truncate_words(content, 25)  # ~160 chars

        elif integration_type == IntegrationType.WEBHOOK:
            # Format for Webhook (minimal, machine-readable)
            formatted_subject = subject or "Agent Response"
            formatted_body = content

        elif integration_type == IntegrationType.TEST:
            # Format for Test (clear test indicators)
            formatted_subject = f"[TEST] {subject or 'Agent Response'}"
            formatted_body = f"ðŸ§ª TEST DELIVERY\n\n{content}"

        else:
            # Default formatting
            formatted_subject = subject or "Agent Response"
            formatted_body = content

        return formatted_subject, formatted_body

    def _truncate_words(self, text: str, word_count: int) -> str:
        """Truncate text to specified word count."""
        words = text.split()
        if len(words) <= word_count:
            return text

        truncated = " ".join(words[:word_count])
        return f"{truncated}..."

    def _markdown_to_slack(self, text: str) -> str:
        """Convert basic markdown to Slack formatting."""
        # Simple markdown to Slack conversion
        text = text.replace("**", "*")  # Bold
        text = text.replace("__", "_")  # Italic
        text = text.replace("`", "`")  # Code (same)

        # Convert headers to bold
        import re

        text = re.sub(r"^#{1,6}\s+(.*?)$", r"*\1*", text, flags=re.MULTILINE)

        return text

    def _markdown_to_html(self, text: str) -> str:
        """Convert basic markdown to HTML."""
        # Simple markdown to HTML conversion
        import re

        # Headers
        text = re.sub(r"^#{6}\s+(.*?)$", r"<h6>\1</h6>", text, flags=re.MULTILINE)
        text = re.sub(r"^#{5}\s+(.*?)$", r"<h5>\1</h5>", text, flags=re.MULTILINE)
        text = re.sub(r"^#{4}\s+(.*?)$", r"<h4>\1</h4>", text, flags=re.MULTILINE)
        text = re.sub(r"^#{3}\s+(.*?)$", r"<h3>\1</h3>", text, flags=re.MULTILINE)
        text = re.sub(r"^#{2}\s+(.*?)$", r"<h2>\1</h2>", text, flags=re.MULTILINE)
        text = re.sub(r"^#{1}\s+(.*?)$", r"<h1>\1</h1>", text, flags=re.MULTILINE)

        # Bold and italic
        text = re.sub(r"\*\*(.*?)\*\*", r"<strong>\1</strong>", text)
        text = re.sub(r"\*(.*?)\*", r"<em>\1</em>", text)
        text = re.sub(r"__(.*?)__", r"<strong>\1</strong>", text)
        text = re.sub(r"_(.*?)_", r"<em>\1</em>", text)

        # Code
        text = re.sub(r"`(.*?)`", r"<code>\1</code>", text)

        # Line breaks
        text = text.replace("\n", "<br>")

        return text
